package or.co.org.coco.kr.ttido.studyJava.Class_Instance;

/*
* 학습의 목표
* 클래스 변수와 인스턴스 변수의 차이를 알아볼 것이다.
* 방법
* 하나의 클래스를 생성 >> 이 곳에 클래스 변수와 인스턴스 변수를 모두 생성 >>> 메인 메소드에서 해당 클래스를 이용해 2개의 인스턴스를 생성해 각각의 매개변수에 참조
* 인스턴스 변수의 값을 변경했을 때의 변화와 클래스 변수를 변화시켰을때의 변화를 통해
* 클래스 변수의 데이터는 객체가 공유한다는 사실을 이해하자.
*
*
* */

class sample{
    static String name ;
    String sample ;

    static void output(){
        System.out.println(name);
//      System.out.println(sample);                           //스테틱으로 선언된 메서드에서 인스턴스 변수를 활용하려고 하자 에러가 발생한다.

    }
    void output01(){
        System.out.println(sample);
    }

}
public class InstanceNClassStudy {
    public static void main(String[] args) {
        sample A = new sample();
        sample B = new sample();

        A.name = "안녕하세요";
        B.name = "반갑습니다.";
        A.output();                                                 //A가 참조하는 인스턴스에서 전역변수 name 에 안녕하세요를 입력하고
        B.output();                                                 //B가 참조하는 인스턴스에서 반갑습니다. 를 입력했다.
                                                                // 그렇다면 출력을각각했을 때 안녕하세요 반갑습니다.가 출력이 되어이하는데
                                                                        // 왜 반갑습니다만 호출이되는가?     그것은 전역변수 이기 때문이다. 즉 전역변수이기 때문에 해당 변수를 모든 인스턴스가 공유한다
                                                                            //그렇기에 값에 안녕하세요의 참조값이 들어가고 그 다음 반갑슨다의 참조값이 들어간것이다.
// 그렇다면 인스턴스 변수를 확인해보자.

        A.sample = " 하이";
        B.sample = " 입니다.";
        A.output01();
        B.output01();                                                           //인스턴스 변수는 각각의 인스턴스에 속해 있기 때문에 출력 결과를 보면 각각 하이 입니다가 출력되는 것을 볼 수 있따.

        /*
        * 클래스 멤버의저장 위치는 메서드 영역이다. 이 영역은 프로그램에서 유일한 것들을 의미하며 인스턴스화 되지 않는다 .즉 프로그램 내에 유일한 하나로 객체간 공유가 된다는 것을 의미한다.
        * 그렇다면 인스턴스 매개변수를 이용해서 호출할 수 있는 이유는 무엇인가?>
        *
        *           인스턴스 매개변수를 이용해서 호출할 수 있는 이유는 클래스 멤버가 코드상 들어간 위치를 이해하면 도움이 된다.
        *
        *           메모리영역에서는 메서드 영역에 존재하지만
        *               코드로 어딘가에 들어가야한다.
        *                       이 것을 방에 비유하자면 클래스 멤버라는 세입자가 자신이 코드상 들어갈 위치를 찾아야하는데 지금과 같은 경우는 Sample이라는 클래스에서 방을 빌려준다고 했다.
        *                           그 결과 Sample은 세입자인 클래스 멤버들에게 .을 붙이지 않고 바로 클래스 멤버를 호출할 수 있는 권리를 얻었다.
        *               나는 클래스 멤버가 인스턴스화 되지 않았다고 말을 했다. 그렇다면 어떻게 인스턴스 참조 변수로 이 것을 호출할 수 있었을끼ㅏ
        *                       그것은 앞서 말한 것처럼 Sample 이라는 클래스는 방을 빌려준 대가로 세입자인 클래스멤버에게 .을 붙이지 않고 호출할 수 있는 권리를 상속받았다 . 이 권리는 상속 or 인스턴스화가 되기때문에 이 권리를이용해 호출한 것이다.
        *
        * */







    }

}
